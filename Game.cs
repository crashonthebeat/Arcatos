using Arcatos.Types;
using Arcatos.Types.Items;
using Arcatos.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;

namespace Arcatos
{
    public class Game
    {        
        public        bool                       Playing      { get; set; }
        public static World                      CurrentWorld { get; set; }
        public static Player                     Player       { get; private set; }
        public static Dictionary<string,Item>    Catalog      { get; private set; } // Common items that can be stacked as they will always be the same
        public static Dictionary<string,ItemDto> Templates  { get; private set; } // Unique items like containers that should not be duplicated.
        public static Boxscope                   Boxscope     { get; private set; }
        public readonly Dictionary<string, Dictionary<string, string[]>> Narration;
        
        // TODO: Make this a static constructor? Not sure how those work yet
        public Game(string currentSceneId)
        {
            // Load all game items
            Game.Catalog   = Game.LoadCommonItems();
            Game.Templates = Game.LoadItemTemplates();
            
            // Get WorldId and Scene for Player State
            string worldId = currentSceneId.Split('_')[0];
            Game.CurrentWorld = new World(worldId);
            (_, Scene currentScene) = Game.CurrentWorld.GetMapObjects(currentSceneId);

            // Load Player (should actually load from file either a saved state or new player state generated by char creation)
            Game.Player = new Player(currentScene);

            // HAIL BOXSCOPE
            Game.Boxscope = new Boxscope();
            Boxscope.UpdateLocal();

            this.Narration = Program.LoadFiles<Dictionary<string, string[]>>("Narration");

            // and now u can play
            this.Playing = true;
        }

        public void Play()
        {
            Game.Player.CurrentScene.Enter();

            this.Prompt();
        }

        // This is the player interface.
        // TODO: This whole interface section will be redone when the game gets more complex.
        // tbh this whole class will probably and definitely change.
        public void Prompt()
        {
            while (Playing)
            {
                Console.Write("> ");
                string? input = Console.ReadLine();

                if (String.IsNullOrEmpty(input)) 
                {
                    Game.Narrate("You didn't enter a command.");
                }
                else 
                {
                    // Create command object from player input.
                    Command command = new(input.ToLower().Split(' '));

                    this.Playing = Game.Player.Execute(command);
                }
            }
        }

        // LoadUniqueItems all the files from the unique folder and loads them as item models for the map processing to instantiate as new objects
        // This allows for less duplication of entries in the unique items list for things like containers that have common properties.
        private static Dictionary<string,ItemDto> LoadItemTemplates()
        {
            // Grab all the item files
            string[] templateFiles = Directory.GetFiles(Path.Combine(Program.Dir, "World", "Items", "templates"));
            
            // Create new dictionary to return to unique items.
            // Key difference between this and common items is that this dict is string to *dto*, not the item itself.
            Dictionary<string,ItemDto> models = new();

            foreach (string file in templateFiles)
            {
                using FileStream json = File.OpenRead(file);
                foreach (KeyValuePair<string, ItemDto> item in JsonSerializer.Deserialize<Dictionary<string, ItemDto>>(json)!)
                {
                    models.Add(item.Key, item.Value);
                }
            }

            return models;
        }

        // Where this method differs from unique items is that this creates the objects themselves in the game catalog
        // Map processing makes references to this object, as the model itself is made to be copied. 
        // What I don't know is if it would make more sense to load everything as unique items, and then changing how boxes work
        // The box.items would then be a List of items, where the qty would be the count and would mix only if the ids mixed and item.isUnique = false.
        // I'm thinking it uses less memory to just do it this way but what do I know.
        private static Dictionary<string, Item> LoadCommonItems()
        {
            string[] commonItemFiles = Directory.GetFiles(Path.Combine(Program.Dir, "World", "Items", "common"));
            
            // New Dictionary to return to common items.
            Dictionary<string,Item> catalog = new();
            
            foreach (string file in commonItemFiles)
            {
                using FileStream json = File.OpenRead(file);
                //ItemDto[] models = JsonSerializer.Deserialize<ItemDto[]>(json)!;
                foreach (KeyValuePair<string, ItemDto> model in JsonSerializer.Deserialize<Dictionary<string, ItemDto>>(json)!)
                {
                    catalog.Add(model.Key, new Item(model.Key, model.Value));
                }
            }

            return catalog;
        }

#region Narration
        // TODO: Canned text to randomize messages for bad input, non-found items, etc. 
        
        // Narrate is a wrapper on top of console.write that takes game narration and presents it to the player.
        // This will have hella overloads, and in fact be broken out into several methods.
        
        
        public static void Narrate(string s)
        {
            Console.WriteLine(s);
        }

        // Narrate overload for a list of strings perchance fed by an Entity's examine method that adds extra topics.
        public static void Narrate(string[] raw)
        {
            string joined = "";
            
            foreach (string s in raw)
            {
                joined += $"{s.Trim()} ";
            }

            Game.Narrate(joined);

            // Todo: Wrap strings based on a detected (or set or standard) console CornerSE.
        }

        // Makes strings into a proper title case for nicer output
        public static string Titleize(string s)
        {
            List<string> words = s.Split(' ').ToList();
            string   output = "";

            // If the first word is a or an, that's the only time it should get capitalized.
            switch (words[0])
            {
                case "a":
                    output += "A ";
                    words.RemoveAt(0);
                    break;
                case "an":
                    output += "An ";
                    words.RemoveAt(0);
                    break;
            }
            
            // Loop through the rest of the words
            foreach (string word in words)
            {
                // Exceptions for capitalization
                if (new[] { "the", "a", "an", "to", "from", "by", "of"}.Contains(word))
                {
                    output += $"{word} ";
                    continue;
                }
                
                // Otherwise, capitalize the first letter of each word.
                output += word.Length == 1 ? $"{word.ToUpper()} " : $"{char.ToUpper(word[0])}{word[1..]} ";
            }
            
            // Return the output and remove the last space.
            return output.Trim();
        }
        
    }

#endregion
}
