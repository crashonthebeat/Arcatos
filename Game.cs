using Arcatos.Types;
using Arcatos.Types.Items;
using Arcatos.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using System.Xml.Schema;

namespace Arcatos
{
    public class Game
    {        
        public        bool                       Playing      { get; set; }
        public static World                      CurrentWorld { get; set; }
        public static Player                     Player       { get; private set; }
        public static Dictionary<string,Item>    Catalog      { get; private set; } // Common items that can be stacked as they will always be the same
        public static Dictionary<string,ItemDto> Templates  { get; private set; } // Unique items like containers that should not be duplicated.
        public static Boxscope                   Boxscope     { get; private set; }

        // TODO: Make this a static constructor? Not sure how those work yet
        public Game(string currentSceneId)
        {
            // Load all game items
            Game.Catalog = LoadCommonItems();
            Game.Templates = LoadItemTemplates();
            
            // Get WorldId and Scene for Player State
            string worldId = currentSceneId.Split('_')[0];
            Game.CurrentWorld = new World(worldId);
            (var _, Scene currentScene) = CurrentWorld.GetMapObjects(currentSceneId);

            // Load Player (should actually load from file either a saved state or new player state generated by char creation)
            Game.Player = new Player(currentScene);

            // HAIL BOXSCOPE
            Game.Boxscope = new Boxscope();
            Boxscope.UpdateLocal();

            // and now u can play
            this.Playing = true;
        }

        public bool Play()
        {
            Game.Player.CurrentScene.Enter();

            return Prompt();
        }

        // This is the player interface.
        // TODO: This whole interface section will be redone when the game gets more complex.
        // tbh this whole class will probably and definitely change.
        public bool Prompt()
        {
            while (Playing)
            {
                Console.Write("> ");
                string? input = Console.ReadLine();

                if (String.IsNullOrEmpty(input)) 
                {
                    Game.Narrate("You didn't enter a command.");
                    continue;
                }
                else 
                {
                    // Create command object from player input.
                    Command command = new Command(input.ToLower().Split(' '));

                    this.Playing = Game.Player.Execute(command);
                }
            }
            return true;
        }

        // LoadUniqueItems all the files from the unique folder and loads them as item models for the map processing to instantiate as new objects
        // This allows for less duplication of entries in the unique items list for things like containers that have common properties.
        private static Dictionary<string,ItemDto> LoadItemTemplates()
        {
            // Grab all the item files
            string[] templateFiles = Directory.GetFiles(Path.Combine(Program.Dir, "World", "Items", "templates"));
            
            // Create new dictionary to return to unique items.
            // Key difference between this and common items is that this dict is string to *dto*, not the item itself.
            Dictionary<string,ItemDto> models = new Dictionary<string,ItemDto>();

            foreach (string file in templateFiles)
            {
                using FileStream json = File.OpenRead(file);
                foreach (KeyValuePair<string, ItemDto> item in JsonSerializer.Deserialize<Dictionary<string, ItemDto>>(json)!)
                {
                    models.Add(item.Key, item.Value);
                }
            }

            return models;
        }

        // Where this method differs from unique items is that this creates the objects themselves in the game catalog
        // Map processing makes references to this object, as the model itself is made to be copied. 
        // What I don't know is if it would make more sense to load everything as unique items, and then changing how boxes work
        // The box.items would then be a List of items, where the qty would be the count and would mix only if the ids mixed and item.isUnique = false.
        // I'm thinking it uses less memory to just do it this way but what do I know.
        private static Dictionary<string, Item> LoadCommonItems()
        {
            string[] commonItemFiles = Directory.GetFiles(Path.Combine(Program.Dir, "World", "Items", "common"));
            
            // New Dictionary to return to common items.
            Dictionary<string,Item> catalog = new Dictionary<string,Item>();
            
            foreach (string file in commonItemFiles)
            {
                using FileStream json = File.OpenRead(file);
                //ItemDto[] models = JsonSerializer.Deserialize<ItemDto[]>(json)!;
                foreach (KeyValuePair<string, ItemDto> model in JsonSerializer.Deserialize<Dictionary<string, ItemDto>>(json)!)
                {
                    catalog.Add(model.Key, new Item(model.Key, model.Value));
                }
            }

            return catalog;
        }

#region Narration
        // TODO: Canned text to randomize messages for bad input, non-found items, etc. 
        
        // Narrate is a wrapper on top of console.write that takes game narration and presents it to the player.
        // This will have hella overloads, and in fact be broken out into several methods.
        public static void Narrate(string s)
        {
            Console.WriteLine(s);
        }

        // Narrate overload for a list of strings perchance fed by an Entity's examine method that adds extra topics.
        public static void Narrate(string[] raw)
        {
            string joined = "";
            
            foreach (string s in raw)
            {
                joined += $"{s.Trim()} ";
            }

            Game.Narrate(joined);

            // Todo: Wrap strings based on a detected (or set or standard) console CornerSE.
        }
        
    }

#endregion
}
