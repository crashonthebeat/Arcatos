using Arcatos.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace Arcatos.Types
{
    // Data Object for the Map Type
    public struct MapDto
    {
        [JsonInclude] public required SceneDto[] scenes;
        [JsonInclude] public required ExitDto[] exits;
        [JsonInclude] public required Dictionary<string, Dictionary<string, int>> inventories;
    }
    
    public class Map
    {
        public Dictionary<string,Scene> Scenes { get; init; }   // Dict of scenes with their id's as key.
        public Dictionary<string,Exit> Exits { get; init; }     // Dict of exits with their id's as key.

        
        // Map Constructor is called by the world's loading function and takes the Dto generated by the map json.
        public Map(MapDto dto, string mapName)
        {
            this.Scenes = new Dictionary<string, Scene>();
            this.Exits = new Dictionary<string, Exit>();

            // Process scenes array in MapDto
            foreach (SceneDto model in dto.scenes)
            {
                // Array Item is SceneDto > Process to Scene
                Scene scene = new Scene(model);

                // Add processed scene under its id.
                this.Scenes.Add( $"{mapName}_{scene.id}", scene );
            }

            // Process Exits array
            foreach (ExitDto model in dto.exits)
            {
                // Grab Scenes from the id names in the ExitDto and create new Exit Object.
                Scene[] adj = [this.Scenes[$"{mapName}_{model.scenes[0]}"], this.Scenes[$"{mapName}_{model.scenes[1]}"]];
                this.Exits.Add(model.id, new Exit(model, adj));
                
                // Add the exit/dir[] pairs for each scene.
                adj[0].ExitPairs.Add(this.Exits[model.id], Calc.RoomDirection(adj[0], adj[1]));
                adj[1].ExitPairs.Add(this.Exits[model.id], Calc.RoomDirection(adj[1], adj[0]));
            }

            // Now resolve all exit pairs HAHAHAHHAHAH THIS PART IS GOING TO KILL ME WHAT HAVE I DONE WHY COULDN'T I JUST LEAVE IT AS IS.
            List<Scene> unresolvedExits = new List<Scene>(this.Scenes.Values);  // Insert picture of robert stack
            while (unresolvedExits.Count > 0) {
                foreach (Scene scene in unresolvedExits)
                {
                    
                }
            }

            // Process Inventories
            foreach (string invId in dto.inventories.Keys)
            {
                string id = $"{mapName}_{invId}";

                Scene scene = this.Scenes[id];
                Dictionary<string, int> itemDefs = dto.inventories[invId];

                scene.LoadItems(itemDefs);
            }
        }
    }
}
