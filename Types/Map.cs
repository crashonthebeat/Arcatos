using Arcatos.Utils;
using System.Text.Json.Serialization;
using System.Xml;

namespace Arcatos.Types
{
    // Data Object for the Map Type
    public struct MapDto
    {
        [JsonInclude] public required SceneDto[] scenes;
        [JsonInclude] public required ExitDto[]  exits;
        
        [JsonInclude] public required Dictionary<string, Dictionary<string, int>> inventories;
    }

    public struct LayoutDto(int x, int y, int width, int height)
    {
        public int[] CornerNW = [x, y];
        public int[] CornerSE = [x + width, y + height];
    }
    
    public class Map
    {
        public           Dictionary<string,Scene>      Scenes { get; } // Dict of scenes with their id's as key.
        private          Dictionary<string,Exit>       Exits  { get; } // Dict of exits with their id's as key.
        private readonly Dictionary<Scene, List<Exit>> _rawExits = new Dictionary<Scene, List<Exit>>();
        
        public static bool Debug = true;
        
        // Map Constructor is called by the world's loading function and takes the Dto generated by the map json.
        public Map(MapDto dto, Dictionary<string, LayoutDto> layouts, string mapName)
        {
            this.Scenes = new Dictionary<string, Scene>();
            this.Exits = new Dictionary<string, Exit>();
            //this._rawExits = new Dictionary<Scene, List<Exit>>();

            Dev.Log("----LOADING SCENES----", Map.Debug);
            // Process scenes array in MapDto
            foreach (SceneDto model in dto.scenes)
            {
                // Array Item is SceneDto > Process to Scene
                Scene scene = new Scene(model, layouts[model.id]);

                // Add processed scene under its id.
                this.Scenes.Add( $"{mapName}_{scene.id}", scene );
                this._rawExits.Add( scene, [ ]);
                Dev.Log($"Loaded {mapName}_{scene.id}", Map.Debug);
            }

            Dev.Log("----LOADING EXITS----", Map.Debug);
            // Process Exits array
            foreach (ExitDto model in dto.exits)
            {
                // Grab Scenes from the id names in the ExitDto and create new Exit Object.
                Scene[] adj = [this.Scenes[$"{mapName}_{model.scenes[0]}"], this.Scenes[$"{mapName}_{model.scenes[1]}"]];
                Dev.Log($"Loading {model.id} - {model.scenes[0]}/{model.scenes[1]}", Map.Debug);
                this.Exits.Add(model.id, new Exit(model, adj));
                
                foreach (Scene scene in adj)
                {
                    if (this._rawExits.TryGetValue(scene, out List<Exit>? value))
                    {
                        value.Add(this.Exits[model.id]);
                    }
                    else
                    {
                        this._rawExits.Add(scene, [ this.Exits[model.id] ]);
                    }
                }
            }

            Dev.Log("----ADDING EXITS TO SCENES----", Map.Debug);
            foreach (KeyValuePair<Scene, List<Exit>> kvp in this._rawExits)
            {
                Dev.Log($"Adding exits for {kvp.Key.id}", Map.Debug);
                kvp.Key.AddExits(kvp.Value);
            }

            // Process Inventories
            foreach (string invId in dto.inventories.Keys)
            {
                string id = $"{mapName}_{invId}";

                Scene scene = this.Scenes[id];
                Dictionary<string, int> itemDefs = dto.inventories[invId];

                scene.LoadItems(itemDefs);
            }
        }
    }
}
